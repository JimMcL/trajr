---
title: "Animal trajectory analysis with trajr"
author: "Jim McLean"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 4
vignette: >
  %\VignetteIndexEntry{Introduction to trajr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = FALSE,
  comment = "#>",
  dev="png",
  global.par = TRUE
)
library("knitr")
library("plotrix")
library("trajr")

# If fastPlots is TRUE, small sample datasets are plotted to save time
fastPlots <- TRUE
```

## Introduction

The `trajr` R package is a toolkit for statistical analysis of the trajectories of moving animals. Trajectory analysis is applicable in fields as diverse as optimal foraging theory, studies of migration, and mimicry theory. A _trajectory_ is simply a record of the path followed by a moving animal. `Trajr` operates on trajectories in the form of a series of locations with times. Trajectories may be obtained by any method which provides this information, including manual tracking, radio telemetry, GPS tracking, and motion tracking from videos. 

The goal of this package (and this document) is to aid biological researchers, who may not have extensive experience with R, to analyse trajectories without being handicapped by a limited knowledge of R or programming. However, a basic understanding of R is required. 

Within this document, the plots are generated by running the code examples immediately before them. For that reason, most code examples start with a call to `TrajGenerate`, which generates a random trajectory to be plotted. These calls would not occur in an analysis of real animal trajectories. 

### Installation and setup

Before using any R package, it is first necessary to install and load it. To install the latest released version of `trajr`, simply run:
```{r, eval=FALSE}
install.packages("trajr")
```

To install the latest development version, which is available on [GitHub](https://github.com/JimMcL/trajr), run:
```{r, eval=FALSE}
install.packages("devtools")
devtools::install_github("JimMcL/trajr")
```
Once the package has been installed, you must load it, then it's ready for use:
```{r eval=FALSE}
library("trajr")
```
Packages only need to be installed once, but they must be loaded in every session before they can be used.

Once the `trajr` package has been installed and loaded, you have access to the set of R functions it provides. All `trajr` functions (other than the generic functions `plot`, `lines` and `points`) start with the prefix `Traj`. Several of the functions provided by `trajr` do not provide additional analytic functionality, rather they make it easier to work with multiple trajectories. These convenience functions are prefixed with `Trajs`.

## Trajectories in `trajr`

`Trajr` works with trajectories, where a trajectory is a simplification of a real path travelled by an animal, and is a set of 2-dimensional spatial coordinates with a third temporal dimension. A trajectory can also be thought of as a series of steps, each comprised of a length (L~i~), a turning angle ($\Delta$~i~), and a time. Trajectories are sometimes separated into two distinct types: correlated random walks, in which the angle of each step is the angle of the previous step Â± some error; and directed walks, or compass-based navigation, in which the angular errors at each step are added to the "ideal" or compass direction. `Trajr` generally assumes random walks, but provides some support for directed walks.

```{r randomWalk, echo=FALSE, fig.height=4, fig.width=6, fig.cap="_A random walk with 5 steps_"}
par(mar = c(4, 4, 0.5, 0.5) + 0.1)
# Generate and plot a short random trajectory
set.seed(4)
trj <- TrajGenerate(5, random = TRUE)
plot(trj, turning.angles = "random")
```

```{r directedWalk, echo=FALSE, fig.height=4, fig.width=6, fig.cap="_A directed walk with 5 steps_"}
par(mar = c(4, 4, 0.5, 0.5) + 0.1)
# Generate and plot a short directed trajectory
set.seed(1)
trj <- TrajGenerate(5, random = FALSE)
plot(trj, turning.angles = "directed")
```

Within `trajr`, trajectories are represented by R objects with class `Trajectory`. The `TrajFromCoords` function is used to create a `Trajectory` object from a set of x-y coordinates, with optional times. 

<!-- NOTE the echo=-1 removes the first line of code from the output, as I want it to run to make the plot look pretty, but it's not relevant to a reader -->
```{r creation, fig.width=6, fig.height=4, fig.cap="_Trajectory created from coordinates_", echo=-1}
par(mar = c(4, 4, 0.5, 0.5) + 0.1)
# Define x, y, and time coordinates
coords <- data.frame(x = c(1, 1.5, 2, 2.5, 3, 4), 
                     y = c(0, 0, 1, 1, 2, 1), 
                     times = c(0, 1, 2, 3, 4, 5))
# Create a trajectory from the coordinates
trj <- TrajFromCoords(coords)

# Plot it
plot(trj)
```

### Creating Trajectories

In practice, trajectory coordinates are typically read from a data file such as a CSV file, and then passed in to the `TrajFromCoords` function. Run `?TrajFromCoords` to access help for the `TrajFromCoords` function, which provides detailed information about creating trajectories from coordinates. In addition, many functions (including `TrajFromCoords`) contain code examples as part of their help information. While examples are part of the help page, you can display and execute an example by calling the `example` function, for example, `example("TrajFromCoords")` will display and run the examples for the `TrajFromCoords` function. 
```{r, eval=FALSE}
coords <- read.csv("mycoords.csv")
trj <- TrajFromCoords(coords)
```

`TrajFromCoords` assumes that the first column in `coords` contains x values, the second contains y values, and the third contains time values. The help page for `TrajFromCoords` describes how to alter these defaults.

### Scaling Trajectories

Trajectories may need to be scaled before analysis. For instance, when a trajectory is extracted from video, the spatial units will be pixels, and require conversion to more meaningful units such as metres. Trajectories are scaled by calling `TrajScale` and specifying the scale factor and the abbreviation of the transformed units. In the case of a trajectory digitised from a video, you can calculate scale as $width^{m}_{o}/width^{p}_{o}$, where $width^{m}_{o}$ is the width of an object in metres, and $width^{p}_{o}$ is the width of the same object in pixels, as measured from the video.
```{r, eval=FALSE}
coords <- read.csv("mycoords.csv")
trj <- TrajFromCoords(coords, spatialUnits = "pixels")
# A 10 mm object had length 47 pixels in the video, scale to metres
trj <- TrajScale(trj, 10 * 1000 / 47, "m")
```

### Smoothing trajectories

Many trajectories will suffer from noise which will bias the results of some analyses. The `TrajSmoothSG` function reduces high frequency noise while preserving the shape of the trajectory, by applying  a Savitzky-Golay smoothing filter. It requires two arguments (in addition to the trajectory), `n`, the filter order, and `m`, the filter length (which must be odd). Refer to the help for the function `sgolayfilt` (run `?signal::sgolayfilt`) for details of the filter function.
```{r smooth, fig.width=6, fig.height=4, fig.cap="_Effect of smoothing a trajectory_", echo=-1:-2}
set.seed(3)
par(mar = c(4, 4, 0.5, 0.5) + 0.1)
trj <- TrajGenerate(200, random = TRUE, angularErrorSd = .25)

# Plot original trajectory
plot(trj, lwd = 2)

# Create a smoothed trajectory
smoothed <- TrajSmoothSG(trj, 3, 31)
# Plot it in slightly transparent red
lines(smoothed, col = "#FF0000A0", lwd = 2)

legend("topright", c("Original", "Smoothed"), lwd = 2, col = c("black", "red"), inset = 0.01)
```

### Resampling trajectories

Some functions require a `Trajectory` with a fixed step length. The process of resampling a trajectory to a fixed step length is called _rediscretization_. The function `TrajRediscretize` implements trajectory resampling using the algorithm described by Bovet & Benhamou (1988).
```{r rediscretize, fig.width=6, fig.height=4, fig.cap="_Rediscretization of trajectory with $\\mu_{L} = 2$ to step length $1$_", echo=-1:-2}
par(mar = c(4, 4, 0.5, 0.5) + 0.1)
set.seed(2)
trj <- TrajGenerate(10, stepLength = 2)

# Plot original trajectory with dots at trajectory coordinates
plot(trj, lwd = 2)
points(trj, draw.start.pt = FALSE, pch = 16, col = "black")

# Resample to step length 1
resampled <- TrajRediscretize(trj, 1)

# Plot rediscretized trajectory in red
lines(resampled, col = "#FF0000A0", lwd = 2)
points(resampled, type = 'p', col = "#FF0000A0", pch = 16)
legend("topright", c("Original", "Rediscretized"), col = c("black", "red"), 
       lwd = 2, inset = c(0.01, 0.02))
```


### Other trajectory operations

This table lists trajectory operations not otherwise addressed by this document. Refer to the help for each function for information.


```{r echo=FALSE, results='asis', fig.align='left'}
kable(data.frame(`Function` = c("`TrajRotate`", "`TrajReverse`",
                                "`TrajGetFPS`", "`TrajGetNCoords`", "`TrajGetUnits`",
                                "`TrajGetTimeUnits`", "`TrajStepLengths`", "`TrajLength`",
                                "`TrajDistance`", "`TrajAngles`"), 
                 Description = c("Rotates a trajectory",
                                 "Reverses a trajectory",
                                 "Returns the frames-per-second of a trajectory",
                                 "Returns the number of coordinates of a trajectory",
                                 "Returns the spatial units of a trajectory",
                                 "Returns the temporal units of a trajectory",
                                 "Returns the lengths of each step within the trajectory",
                                 "Returns the total length of the trajectory",
                                 "Returns the straight-line distance from the start to the end of the trajectory",
                                 "Returns the turning angles (radians) of a trajectory")),
      caption = "_Miscellaneous `trajr` functions._")

```


## Trajectory analysis

Once you have obtained a correctly scaled `Trajectory` object, you may call various functions to analyse the trajectory. Broadly speaking, analysis may be divided into measures of speed or acceleration, and measures of straightness or tortuosity.

### Analysing speed

The `TrajDerivatives` function calculates linear speed and acceleration along a `Trajectory`. If the trajectory is noisy, it should be smoothed before the derivatives are calculated (see [Smoothing trajectories](#smoothing-trajectories)).

```{r speed, fig.cap="_Speed and acceleration over time_", fig.width=6, fig.height=4, echo=-1:-2}
set.seed(1)
par(mar = c(4, 4.5, 1, 4.5) + 0.1)
trj <- TrajGenerate()

# Smooth before calculating derivatives
smoothed <- TrajSmoothSG(trj, 3, 101)

# Calculate speed and acceleration
derivs <- TrajDerivatives(smoothed)

# Plot acceleration and speed
plot(derivs$acceleration ~ derivs$accelerationTimes, type = 'l', col = 'red', 
     yaxt = 'n',
     xlab = 'Time (s)',
     ylab = expression(paste('Acceleration (', m/s^2, ')')))
axis(side = 2, col = "red")
lines(derivs$speed ~ derivs$speedTimes, col = 'blue')
axis(side = 4, col = "blue")
mtext('Speed (m/s)', side = 4, line = 3)
abline(h = 0, col = 'lightGrey')
```

Once the trajectory speed and acceleration have been obtained, it is simple to calculate values such as mean, maximum, minimum or standard deviation of speed (or acceleration): `mean(derivs$speed)`, `max(derivs$speed)`, `min(derivs$speed)`, or `sd(derivs$speed)`. Similarly, calculations excluding periods when speed drops below (or above) some value are also straightforward, for example: `mean(derivs$speed[deriv$speed > STOPPED_SPEED])`. In addition, the function `TrajSpeedIntervals` allows you to determine the time intervals within the trajectory that satisfy a speed constraint, either slower than some speed, faster than a speed, or both. This may be useful, for example, when testing how often, or for how long, a flying insect hovers, i.e. when its speed drops below some threshold. The object returned by a call to `TrajSpeedIntervals` can be plotted.


```{r speedIntervals, fig.cap="_Speed over time, hovering intervals (speed < 2 m/s) highlighted_", fig.width=6, fig.height=4, echo=-1:-2}
set.seed(1)
par(mar = c(4, 4, 0.5, 0.5) + 0.1)
# Simulate a flying bee
trj <- TrajGenerate(100, angularErrorSd = 0.3, stepLength = 0.001)
# Smooth the trajectory
trj <- TrajSmoothSG(trj, 3, 51)

# Calculate hovering intervals
intervals <- TrajSpeedIntervals(trj, slowerThan = 2)
print(intervals)

# Plot speed over time with hovering intervals highlighted
plot(intervals)
```

### Analysing straightness

#### Straightness index

Various methods to measure the straightness, or conversely, tortuosity, of trajectories are available within `trajr`. The simplest is simply $D/L$, where $D$ is the distance from the start to the end of the trajectory, and $L$ is the length of the trajectory. This straightness index is calculated by the function `TrajStraightness`, and is a number ranging from 0 to 1, where 1 indicates a straight line. Benhamou (2004) considers the straightness index to be a reliable measure of the efficiency of a directed walk, but inapplicable to random trajectories.

Within this section, most of the figures show the statistic plotted for multiple trajectories which vary in their sinuosity. Sinuosity is varied by generating random trajectories with different standard deviations of angular errors.

#### Sinuosity

The sinuosity index devised by Bovet & Benhamou (1988) may be an appropriate measure of the tortuosity of a random search path (Benhamou 2004). Sinuosity is a function of the standard deviation of the turning angles in the trajectory. The function `TrajSinuosity` calculates the sinuosity, and should be applied to a [rediscretized](#resampling-trajectories) trajectory.

```{r Sinuosity, fig.cap="_Sinuosity as a function of angular error (linear axes), plotted for several different step sizes_", fig.height=4, fig.width=6, echo=c(-1,-2,-4)}
set.seed(1)
par(mar = c(4, 4, 0.5, 0.5) + 0.1)
n <- 5000
n <- ifelse(fastPlots, 100, n) # If debugging, small value for faster knitting. This line is hidden
# Random magnitude of angular errors
angularErrorSd <- runif(n, 0, 2)

# Generate some trajectories with varying angular errors
trjs <- lapply(1:n, function(i) TrajGenerate(500, stepLength = 2, 
                                             angularErrorSd = angularErrorSd[i]))

# Rediscretize each trajectory to a range of step sizes
stepSizes <- c(1, 2, 10)
reds <- lapply(stepSizes, function(ss) lapply(1:n, function(i) TrajRediscretize(trjs[[i]], ss)))

# Calculate sinuosity for all of the rediscretized trajectories
sins <- sapply(reds, function(trjs) sapply(1:n, function(i) TrajSinuosity(trjs[[i]])))

# Plot sinuosity vs angular error
plot(rep(angularErrorSd, 3), sins,
     pch = 16, cex = .2, 
     col = c(rep('red', n), rep('blue', n), rep('darkgreen', n)),
     xlab = expression(sigma["angular error"]), ylab = "Sinuosity")

legend("bottomright", c("Step length 1", "Step length 2", "Step length 10"), 
       pch = 16, col = c("red", "blue", "darkgreen"), inset = 0.01)
```

#### E~max~

$E^{a}_{max}$ is a dimensionless estimate of the maximum expected displacement of a trajectory: the greater the value (approaching infinity), the straighter the path (Cheung, Zhang, Stricker, & Srinivasan, 2007). $E^{b}_{max}$ is $E^{a}_{max}$ multiplied by the mean step length, so gives the maximum possible displacement in spatial units. `TrajEmax` returns the value of $E^{a}_{max}$ for a trajectory, or $E^{b}_{max}$ if the argument `eMaxB` is `TRUE`. `TrajEmax` differentiates between random and directed walks; see `?TrajEmax` for details.

```{r emax, fig.cap="_E~max~ as a function of angular error (logarithmic axes)_", fig.height=4, fig.width=6, echo=-1}
par(mar = c(4, 4, 1.5, 0.5) + 0.1)
# Calculate Emax for all of the rediscretized trajectories (from the previous example)
emaxs <- sapply(reds, function(trjs) sapply(1:n, function(i) TrajEmax(trjs[[i]])))
emaxs[emaxs < 0] <- NA # Avoid warnings when plotting on log axes

# Plot Emax vs angular error on log axes
plot(rep(angularErrorSd, 3), emaxs,
     log = 'xy',
     pch = 16, cex = .2, 
     col = c(rep('red', n), rep('blue', n), rep('darkgreen', n)),
     xlab = expression(sigma["angular error"]), ylab = expression(E[max]))

legend("bottomleft", c("Step length 1", "Step length 2", "Step length 10"), 
       pch = 16, col = c("red", "blue", "darkgreen"), inset = 0.01)
```

#### Fractal dimension

Fractal dimension has been considered a promising measure of straightness or tortuosity, varying between 1 (straight line movement) and 2 (Brownian motion). However, several studies have found it inappropriate for use with animal trajectories, as animal trajectories are not fractal curves, and the fractal dimension of a non-fractal curve  depends critically on the range of step sizes used to calculate it (Nams, 2006; Turchin, 1996). Nonetheless, fractal dimension continues to be used, and the `TrajFractalDimension` function, by default, calculates fractal dimension using the modified dividers method to account for truncation error (Nams, 2006). See `?TrajFractalDimension` and `?TrajFractalDimensionValues` for more information.

```{r fractal, fig.cap="_Fractal dimension as a function of angular error_", fig.width=6, fig.height=4, echo=-1}
par(mar = c(4, 4, 0.5, 0.5) + 0.1)
# Use the same step sizes for all trajectories
stepSizes <- TrajLogSequence(.1, 7, 20)

# Fractal dimension is a slow calculation, so just plot a subset of trajectories from the previous example
fn <- n / 10
use <- sample.int(fn, n = length(angularErrorSd))
fangularErrorSd <- angularErrorSd[use]

# Calculate fractal dimension for all of the rediscretized trajectories
d <- sapply(reds, function(trjs) sapply(use, function(i) TrajFractalDimension(trjs[[i]], stepSizes)))

# Plot fractal dimension vs angular error
plot(rep(fangularErrorSd, 3), d,
     pch = 16, cex = .5, 
     col = c(rep('red', fn), rep('blue', fn), rep('darkgreen', fn)),
     xlab = expression(sigma["angular error"]), ylab = expression(E[max]))

legend("topleft", c("Step length 1", "Step length 2", "Step length 10"), 
       pch = 16, col = c("red", "blue", "darkgreen"), inset = 0.01)
```

#### Directional change (DC and SDDC)

Directional change is defined as the change in direction over time, and has been used to assess locomotor mimicry in butterflies (Kitamura & Imafuku, 2015). Directional change is defined for each pair of steps, so a trajectory (or a portion thereof) may be characterised by the mean (`DC`) and standard deviation (`SDDC`) of all directional changes. `DC` may be used as an index of nonlinearity, and `SDDC` as a measure of irregularity. The directional changes for a trajectory are calculated by the function `TrajDirectionalChange`, so `SD` may be calculated as `mean(TrajDirectionalChange(trj))`, and `SDDC` as `sd(TrajDirectionalChange(trj))`. Note that directional change cannot be calculated on rediscretized trajectories, as rediscretizing loses time information.

```{r DC, fig.cap="_DC and SDDC as a function of angular error_", fig.height=4, fig.width=6, echo=-1}
par(mar = c(4, 4, 0.5, 0.5) + 0.1)
# Calculate DC and SDDC for all of the original trajectories (from above)
dcs <- sapply(1:n, function(i) mean(TrajDirectionalChange(trjs[[i]])))
sddcs <- sapply(1:n, function(i) sd(TrajDirectionalChange(trjs[[i]])))

# Plot DC vs angular error
plot(angularErrorSd, dcs,
     pch = 16, cex = .2, col = "blue",
     xlab = expression(sigma["angular error"]), ylab = "DC")
points(angularErrorSd, sddcs, pch = 16, cex = .2, col = 'red')
legend("bottomright", c("DC", "SDDC"), 
       pch = 16, col = c("blue", "red"), inset = 0.01)
```

#### Direction autocorrelation

The direction autocorrelation function was devised to detect and quantify regularities within trajectories, in the context of locomotor mimicry of ant-mimics (Shamble, Hoy, Cohen, & Beatus, 2017). It detects wave-like periodicities, and provides an indication of their wavelength and amplitude, so can be used to detect, for example, the winding movements of trail-following ants. The function $C(\Delta s)$ is applied to a rediscretized trajectory, and calculates the differences in step angles at all steps separated by $\Delta$, for a range of $\Delta s$. The position of the first local minimum in $C(\Delta s)$ (i.e. the 2-dimensional position $(\Delta s, c(\Delta s))$) may be used to characterise the periodicity within a trajectory.

The function is calculated by `TrajDirectionAutocorrelations`, and the result may be plotted. The position of the first local minimum (or maximum) is calculated by `TrajDAFindFirstMinimum` (or `TrajDAFindFirstMaximum`).

```{r dirnAuto, fig.cap="_Direction autocorrelation of a random trajectory with first local minimum_", fig.width=6, fig.height=4, echo=-1:-2}
set.seed(1)
par(mar = c(4, 4, 0.5, 0.5) + 0.1)
trj <- TrajGenerate(1000)
corr <- TrajDirectionAutocorrelations(trj)
plot(corr)
```

## Working with multiple trajectories

### Building multiple trajectories

As trajectory studies are likely to involve multiple trajectories, `trajr` provides some functions to simplify this process. `TrajsBuild` assumes that you have a set of trajectory files (such as CSV files), each of which may have a scale and a frames-per-second value. The function reads each of the files specified in a list of file names, optionally using a custom function, then passes the result to `TrajFromCoords`, which assumes that the first column is `x`, the second is `y`, and there is no time column. If these settings are incorrect, the `csvStruct` argument can be specified to identify the `x`, `y` and `time` columns (see the example below). `TrajsBuild` optionally scales the trajectories with the specified scale (by calling `TrajScale`), and optionally smooths them with the specified smoothing parameters (by calling `TrajSmoothSG`). The value returned is a list of `Trajectory` objects.

```{r multBuild}
tracks <- as.data.frame(rbind(
  c("3527.csv", "Zodariid2 sp1",     "spider",       "red"),
  c("3530.csv", "Daerlac nigricans", "mimic bug",    "blue"),
  c("3534.csv", "Daerlac nigricans", "mimic bug",    "blue"),
  c("3537.csv", "M. erythrocephala", "mimic spider", "blue"),
  c("3542.csv", "Polyrhachis sp1",   "ant",          "black"),
  c("3543.csv", "Polyrhachis sp1",   "ant",          "black"),
  c("3548.csv", "Crematogaster sp1", "ant",          "black")
), stringsAsFactors = FALSE)
colnames(tracks) <- c("filename", "species", "category", "col")
# Order of columns in the CSV files is unknown so identify them by name
csvStruct <- list(x = "x", y = "y", time = "Time")
trjs <- TrajsBuild(tracks$filename, scale = .220 / 720, 
                   spatialUnits = "m", timeUnits = "s", 
                   csvStruct = csvStruct, rootDir = "..")
```

### Calculating statistics for multiple trajectories

`TrajsMergeStats` simplifies the construction of a data frame of statistics, with one row per trajectory. To use it, you need a list of trajectories (which you will probably obtain from a call to `TrajsBuild`), and a function which calculates statistics for a single trajectory. The following example demonstrates how you might write and use such a function.

```{r multstats}
# Define a function which calculates some statistics
# of interest for a single trajectory
characteriseTrajectory <- function(trj) {
  # Measures of speed
  derivs <- TrajDerivatives(trj)
  mean_speed <- mean(derivs$speed)
  sd_speed <- sd(derivs$speed)

  # Measures of straightness
  sinuosity <- TrajSinuosity(trj)
  resampled <- TrajRediscretize(trj, .001)
  Emax <- TrajEmax(resampled)

  # Periodicity
  corr <- TrajDirectionAutocorrelations(resampled, 60)
  first_min <- TrajDAFindFirstMinimum(corr)

  # Return a list with all of the statistics for this trajectory
  list(mean_speed = mean_speed,
       sd_speed = sd_speed,
       sinuosity = sinuosity,
       Emax = Emax,
       min_deltaS = first_min[1],
       min_C = first_min[2]
  )
}

# Calculate all stats for trajectories in the list
stats <- TrajsMergeStats(trjs, characteriseTrajectory)
print(stats)
```

### PCA analysis of multiple trajectories

Principal components analysis (PCA) is a commonly used statistical technique which can be used to visualise similarities and differences between groups of trajectories. In R, the function `prcomp` is usually used to perform a PCA. `Prcomp` will not process data containing `NA`s (in R, the value `NA` is used to indicate a '`N`ot `A`vailable', or missing, value). However, `NA`s can be potentially informative, especially when using the first local minimum of the direction autocorrelation function - in this case, an `NA` indicates that there was no periodicity detected in the trajectory. To avoid discarding this information, `Trajr` provides a utility function, `TrajsStatsReplaceNAs`. It is used to replace `NA` values with some other value, and optionally adds an additional column to the data which flags trajectories which originally contained `NA` values. It operates on a single column at a time. 

```{r pca, fig.cap="_PCA of trajectory characterisations_", fig.width=6, fig.height=4, echo=-1}
par(mar = c(4, 4, 0.5, 0.5) + 0.1)
#---
# Custom PCA plotting function
customPcaPlot <- function(x, xlabs, xcols, choices = 1L:2L, ycol = "#ff2222aa", ...) {
  # Draw points
  pts <- t(t(x$x[, choices]))
  plot(pts, type = "p", 
       xlim = extendrange(pts[, 1L]), ylim = extendrange(pts[, 2L]), 
       asp = 1,
       xlab = "PC1", ylab = "PC2", pch = 16, col = xcols, ...)
  text(pts, labels = xlabs, pos = 1, ...)
  
  # Draw arrows
  axs <- t(t(x$rotation[, choices])) * 3.5
  text(axs, labels = dimnames(axs)[[1L]], col = ycol, ...)
  arrows(0, 0, axs[, 1L] * .8, axs[, 2L] * .8, length = .1, col = ycol)
}
# ---

# Get rid of NAs in the data because prcomp can't handle them
# First fix min_deltaS, and add an extra column which flags non-periodic trajectories
pcaStats <- TrajsStatsReplaceNAs(stats, "min_deltaS", 
                                 replacementValue = 2 * max(stats$min_deltaS, na.rm = TRUE),
                                 flagColumn = "no_first_min")
# Now fix min_C - no need to add another column since it would duplicate no_first_min
pcaStats <- TrajsStatsReplaceNAs(pcaStats, "min_C",
                                 replacementValue = 2 * max(stats$min_C, na.rm = TRUE))
# Perform the PCA
PCA <- prcomp(pcaStats, scale. = TRUE)
# Plot it using custom plotting function. Could just call biplot instead
customPcaPlot(PCA, tracks$category, tracks$col, cex = .8)
legend("topleft", c("Spider", "Mimic", "Ant"), pch = 16, 
       col = c('red', 'blue', 'black'), inset = 0.01)
```

The plot above shows that the trajectory of the non-mimetic spider (red dot) seems quite different from the trajectories of  ant mimicking bugs, ant-mimicking spiders (blue dots) and ants (black dots). The arrows indicate the importance and direction of the parameters that separate the trajectories. From the plot, it seems that the non-mimetic spider varies mainly in speed (it is faster) and E~max~ (it walks in a straighter path). While these trajectories have been digitised from videos of walking animals, clearly this example does not contain enough data to be meaningful.

### Other operations

The function `TrajsStepLengths` returns a vector containing all of the step lengths in a list of trajectories.
```{r}
summary(TrajsStepLengths(trjs))
```

## Random trajectory generation

`Trajr` allows you to generate random trajectories with the `TrajGenerate` function. Random trajectories may be used in simulation studies, or simply for experimenting with trajectory analysis, and it has been used to generate the majority of trajectories in this document. By default, `TrajGenerate` returns a random correlated walk, however, by specifying different arguments, a variety of trajectory types can be created.
```{r generate, fig.width=6, fig.height=4, fig.cap="_Some generated trajectories. a) correlated walk, b) directed walk, c) brownian motion, d) Levy flight._", echo=-1:-2}
set.seed(1)
par(mfrow = c(2, 2), mar = c(4, 4, 0.5, 0.5) + 0.1)
# Random correlated walk
trj <- TrajGenerate(n = 200)
# Plot it
plot(trj)
mtext("a)", 3, -1.3, adj = .05)

# Directed walk
trj <- TrajGenerate(n = 20, random = FALSE)
plot(trj)
mtext("b)", 3, -1.3, adj = .05)

# Brownian motion
trj <- TrajGenerate(n = 500, angularErrorDist = function(n) stats::runif(n, -pi, pi))
plot(trj)
mtext("c)", 3, -1.3, adj = .05)

# Levy flight - path lengths follow a cauchy distribution
trj <- TrajGenerate(linearErrorDist = stats::rcauchy)
plot(trj)
mtext("d)", 3, -1.3, adj = .05)
```

### Some examples

#### Expect travel distance

Following is an implementation of a simulation study from (Cheung at el., 2007). It plots the expected endpoints of multiple random trajectories after different numbers of steps, illustrating the difference in expected distance travelled between directed and random walks. It demonstrates that, for travel without a compass (i.e. an external means to determine direction), the distance travelled along an intended direction does not increase in proportion to the number of steps, which implies an upper limit to the distance that can be travelled without a compass.

```{r directWalks, fig.cap="_Computer simulation of the results of compass-based navigation._", fig.height=4.5, fig.width=6, echo=c(-1,-2)}
set.seed(1)
par(mfrow = c(2, 3), mar = c(4, 4, 3, 1))
ntraj <- 1000 # Cheung at el. used 20000, but it's slow

# Define a function to simulate journeys of different lengths
simulateJourneys <- function(random, nTrajectories = ntraj) {

  generate <- function(i) {
    # These parameters replicate the simulations in (Cheung et al., 2007)
    TrajGenerate(n = 500, random = random, stepLength = 2, 
                 linearErrorSd = 0.2, angularErrorSd = 0.5)
  }
  
  trjs <- lapply(1:nTrajectories, generate)
  
  # Use same plot axes as in the original article
  if (random) {
    xlims <- list(c(-20, 20), c(-20, 20), c(-20, 20), c(-40, 40), c(-170, 170), c(-400, 400))
    ylims <- xlims
  } else {
    xlims <- list(c(-20, 20), c(-20, 20), c(-20, 20), c(20, 50), c(140, 200), c(810, 950))
    ylims <- list(c(-20, 20), c(-20, 20), c(-20, 20), c(-20, 20), c(-30, 30), c(-70, 70))
  }
  
  # 6 plots in 2 rows
  par(mfrow = c(2, 3))
  steps <- c(1, 2, 5, 20, 100, 500)
  for(i in 1:length(steps)) {
    step <- steps[i]
    title <- sprintf("%d %s", step, ifelse(step == 1, "step", "steps"))
    # Plot the end-points of each journey after "step" steps
    endPoints <- t(sapply(trjs, function(t) t[step + 1, c('x', 'y')]))
    plot(endPoints, pch = '.', asp = 1, main = title, xlim = xlims[[i]], ylim = ylims[[i]])
  }
}

# Call the function
simulateJourneys(random = FALSE)
```

```{r randomWalks, fig.cap="_Computer simulation of the results of navigation without a compass._", fig.height=4.5, fig.width=6, echo=-1:-2}
set.seed(1)
par(mfrow = c(2, 3), mar = c(4, 4, 3, 1))
simulateJourneys(random = TRUE)
```

#### Random or directed?

Benhamou (2006) defines a method, called backward pattern analysis, to determine whether a trajectory is a random or directed walk. Here we test it on a number of randomly generated trajectories, and report the failure rate.


```{r bPA}

# Returns TRUE if trj is a random trajectory according to backward pattern analysis (Benhamou, 2006)
isRandom <- function(trj) {
  # For each pair of points along the trajectory,
  # calculate distance between the points
  D <- sapply(1:(nrow(trj) - 1), function(j) TrajDistance(trj, j, nrow(trj)))
  # calculate path length between points
  L <- sapply(1:(nrow(trj) - 1), function(j) TrajLength(trj, j, nrow(trj)))
  # Calculate linear regression with 0 intercept: D vs L
  dir <- lm(D ~ L - 1)
  # D vs sqrt(L)
  sL <- sqrt(L)
  rnd <- lm(D ~ sL - 1)

  # Pick the linear regression with the smallest sum of squared residuals
  sum(rnd$residuals ^ 2) < sum(dir$residuals ^ 2)
}

# Generate some random trajectories, randomly choosing 
# between random search path and directed walks
set.seed(1)
search <- sample(c(TRUE,FALSE), 1000, TRUE) # search/directed flag
results <- sapply(1:length(search), function(i) {
  c(search[i], isRandom(TrajGenerate(100, random = search[i]))) 
  })
# Flags whether the algorithm correctly identified the trajectory type
correct <- results[1,] == results[2,]
t <- table(data.frame(correct, results[1,]))

cat(sprintf("Backward pattern analysis misclassified %g%% of random walks, and %g%% of directed walks\n", 
            100 * t[1,2] / sum(t), 100 * t[1,1] / sum(t)))
```

## And finally...

`Trajr` is open source, with the source available on [Github](https://github.com/JimMcL/trajr). If you have any problems or suggestions, email jim_mclean@optusnet.com.au.

## References

Benhamou, S. (2004). How to reliably estimate the tortuosity of an animal's path. Journal of Theoretical Biology, 229(2), 209-220. \doi{10.1016/j.jtbi.2004.03.016}

Benhamou, S. (2006). Detecting an orientation component in animal paths when the preferred direction is individual-dependent. Ecology, 87(2), 518-528. \doi{10.1890/05-0495}

Bovet, P., & Benhamou, S. (1988). Spatial analysis of animals' movements using a correlated random walk model. Journal of Theoretical Biology, 131(4), 419-433. \doi{10.1016/S0022-5193(88)80038-9}

Cheung, A., Zhang, S., Stricker, C., & Srinivasan, M. V. (2007). Animal navigation: the difficulty of moving in a straight line. Biological Cybernetics, 97(1), 47-61. \doi{10.1007/s00422-007-0158-0}

Kitamura, T., & Imafuku, M. (2015). Behavioural mimicry in flight path of Batesian intraspecific polymorphic butterfly Papilio polytes. Proceedings of the Royal Society B: Biological Sciences, 282(1809). \doi{10.1098/rspb.2015.0483}

Nams, V. O. (2006). Improving Accuracy and Precision in Estimating Fractal Dimension of Animal movement paths. Acta Biotheoretica, 54(1), 1-11. \doi{10.1007/s10441-006-5954-8}

Shamble, P. S., Hoy, R. R., Cohen, I., & Beatus, T. (2017). Walking like an ant: a quantitative and experimental approach to understanding locomotor mimicry in the jumping spider Myrmarachne formicaria. Proceedings of the Royal Society B: Biological Sciences, 284(1858). \doi{10.1098/rspb.2017.0308}

Turchin, P. (1996). Fractal Analyses of Animal Movement: A Critique. Ecology, 77(7), 2086-2090. \doi{10.2307/2265702}
