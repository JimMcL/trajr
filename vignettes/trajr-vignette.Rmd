---
title: "Animal trajectory analysis with trajr"
author: "Jim McLean"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to trajr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  cache=TRUE
)
library("plotrix")
library(trajr)
```

Trajr is an R toolkit for the statistical analysis of animal trajectories.

## Trajectories

Trajr is used to analyse 2-dimensional trajectories with an additional time component. A trajectory can also be thought of as a series of steps, each with a length and a turning angle.

```{r fig.cap="Simple random and directed trajectories", fig.height=8, fig.width=6}
par(mar=c(4, 4, 3, 1), mfrow = c(2, 1))
n <- 5

# Generate a random walk trajectory
set.seed(4)
trj <- TrajGenerate(n, random = TRUE)
plot(trj, main = "Random walk", turning.angles = "random")

# Generate a random directed walk trajectory
set.seed(1)
trj <- TrajGenerate(n, random = FALSE)
plot(trj, main = "Directed walk", turning.angles = "directed")

```

## Analysing trajectory speed

```{r speed, fig.cap="Speed over time, slow intervals (< 90 units/sec) highlighted", fig.width=6, fig.height=4}
plotIntervalsByTime <- function(trj, slowerThan, fasterThan) {
    derivs <- TrajDerivatives(trj)
    speed <- derivs$speed
    plot(x = derivs$speedTimes, y = speed, type = 'l', xlab = 'Time (sec)', ylab = "Speed")
    abline(h = slowerThan, col = "red")
    abline(h = fasterThan, col = "green")
    intervals <- TrajSpeedIntervals(trj, slowerThan = slowerThan, fasterThan = fasterThan)
    rect(intervals$startTime, min(speed), intervals$stopTime, max(speed), col = "#0000FF1E", border = NA)
}

set.seed(1)
trj <- TrajGenerate(100, angularErrorSd = .2)
# smooth as noise is amplified by speed derivation
trj <- TrajSmoothSG(trj, 3, 41)
plotIntervalsByTime(trj, 90, NULL)
```

## Expected results of navigation

Plot the expected results of navigation with and without a compass, based on (Cheung, Zhang, Stricker, & Srinivasan, 2007).

```{r directWalks, fig.cap="Simulated directed journeys", fig.height=5, fig.width=6, cache=TRUE}
simulateJourneys <- function(random, nTrajectories = 10000) {
  trjs <- lapply(1:nTrajectories, function(i) TrajGenerate(n = 500, random = random))
  par(mfrow = c(2, 3), mar = c(4, 4, 3, 1))
  for(step in c(1, 2, 5, 20, 100, 500)) {
    title <- sprintf("%d %s", step, ifelse(step == 1, "step", "steps"))
    plot(t(sapply(trjs, function(t) t[step + 1,c('x', 'y')])), pch  = '.', main = title, asp = 1)
  }
}
simulateJourneys(random = FALSE)
```

```{r randomWalks, fig.cap="Simulated random journeys", fig.height=5, fig.width=6, cache=TRUE}
simulateJourneys(random = TRUE)
```


## Emax

Empirical testing of Emax with generated trajectories.

```{r Emax, fig.cap="Emax as a function of angular error (log-log axes)", cache=TRUE, fig.height=4, fig.width=6}
set.seed(1)
n <- 5000
angularErrorSd <- runif(n, 0, 2)

# Assess Emax for some different types of trajectories, all with the same angular error sd
emaxr <- sapply(1:n, function(i) { TrajEmax(TrajGenerate(500, random = TRUE, angularErrorSd = angularErrorSd[i])) })
emaxd <- sapply(1:n, function(i) { TrajEmax(TrajGenerate(500, random = FALSE, angularErrorSd = angularErrorSd[i]), compass.direction = 0) })
emaxSm <- sapply(1:n, function(i) { TrajEmax(TrajRediscretize(TrajGenerate(500, random = TRUE, angularErrorSd = angularErrorSd[i]), R = 1)) })
emaxBig <- sapply(1:n, function(i) { TrajEmax(TrajRediscretize(TrajGenerate(500, random = TRUE, angularErrorSd = angularErrorSd[i]), R = 10)) })
emaxBig[emaxBig < 0] <- NA # can't take log of negative numbers

par(mar = c(4, 4, 1, 1))
plot(rep(angularErrorSd, 4), c(emaxr, emaxd, emaxSm, emaxBig),
     log = 'xy', pch = '.', 
     col = c(rep('red', n), rep('blue', n), rep('green', n), rep('black', n)),
     xlab = expression(sigma["angular error"]), ylab = expression("E"["max"]))
       labels <- c("Random walk", 
                   "Directed walk", 
                   "Random walk, step length 1", 
                   "Random walk, step length 10")
legend("bottomleft", labels, pch = 16, col = c("red", "blue", "green", "black"), inset = 0.01)
```


## Sinuosity

Empirical testing of Sinuosity with generated trajectories.

```{r Sinuosity, fig.cap="Sinuosity as a function of angular error (linear axes)", cache=TRUE, fig.height=4, fig.width=6}
set.seed(1)
n <- 5000
angularErrorSd <- runif(n, 0, 2)

# Assess sinuosity for some different types of trajectories, all with the same angular error sd
sinur <- sapply(1:n, function(i) { 
  TrajSinuosity(TrajGenerate(500, random = TRUE, angularErrorSd = angularErrorSd[i])) 
})
sinud <- sapply(1:n, function(i) { 
  TrajSinuosity(TrajGenerate(500, random = FALSE, angularErrorSd = angularErrorSd[i]),
                compass.direction = 0) 
})
sinuSm <- sapply(1:n, function(i) { 
  TrajSinuosity(TrajRediscretize(TrajGenerate(500, random = TRUE, 
                                              angularErrorSd = angularErrorSd[i]), 
                                 R = 1)) 
})
sinuBig <- sapply(1:n, function(i) { 
  TrajSinuosity(TrajRediscretize(TrajGenerate(500, random = TRUE, 
                                              angularErrorSd = angularErrorSd[i]), 
                                 R = 10)) 
})

par(mar = c(4, 4, 1, 1))
plot(rep(angularErrorSd, 4), c(sinur, sinud, sinuSm, sinuBig),
     pch = '.', 
     col = c(rep('red', n), rep('blue', n), rep('green', n), rep('black', n)),
     xlab = expression(sigma["angular error"]), ylab = "Sinuosity")
legend("bottomright", c("Random walk", "Directed walk", "Random walk, step length 1", "Random walk, step length 10"), pch = 16, col = c("red", "blue", "green", "black"), inset = 0.01)
```


## Relationship between Emax and Sinuosity

```{r, emax_sinuosity, fig.cap="Relationship between Emax and Sinuosity", fig.width=6, fig.height=4}
set.seed(1)
n <- 5000
angularErrorSd <- runif(n, 0, 2)

xy <- sapply(1:n, function(i) {
  trj <- TrajGenerate(500, angularErrorSd = angularErrorSd[i])
  c(Emax = TrajEmax(trj), sinuosity = TrajSinuosity(trj))
})
xy <- xy[, which(xy[1,] > 0)]
plot(log(xy[1,]), xy[2,], pch = '.', xlab = expression(log(E[max])), ylab = "Sinuosity")
```

## Fractal dimension

```{r fractal, fig.cap="Fractal dimension", fig.width=6, fig.height=4}
set.seed(1)
n <- 100
angularErrorSd <- runif(n, 0, 2)

dim <- sapply(1:n, function(i) { 
  trj <- TrajGenerate(500, random = TRUE, angularErrorSd = angularErrorSd[i])
  TrajFractalDimension(trj, TrajFractalStepSizes(trj, largestStepFactor = 0.01))
})
plot(angularErrorSd, dim, pch = 16, xlab = expression(sigma["angular error"]), ylab = "Fractal dimension")

```
